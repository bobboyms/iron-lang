fn main() {

    /*
    função sem retorno
    */
    let nad1 = () -> 2 + 2
    let nad2 = () -> {
        if true {
           let bv = () int -> 2
        }
        let bv = () int -> 2
    }

    /*
    função com retorno
    */
    let func1 = () int -> 2 + 2
    let func2 = (x int, y float) int -> (x + y) * 3
    let func3 = () int -> {
        let x = 10
        let inFunc = (x int) -> {
            let nn = x
        }
        inFunc(x)

        let inFunc2 = () int -> {
            2
        }

        return inFunc2()
    }

    /*
    criação da função passando como parametro outra função
    */
    fn testx(a int, c int, xp(a int, c int)int, save()) int {
       save()
       /*
       Criação de uma função dentro de outra função
       */
       fn inter1() int {
            fn inter2() int {
                6
            }
            2 + 3 * inter2()
       }

       xp(a,c) + inter1()

    }

    /*
    Executando uma função passando outra função como parâmetro
    */
    let save = () -> 2 + 3
    let result = testx(1,2,(a int, b int) int -> a * b, save)

    let funcx = (pFunc(x int, y float)int, n int, p int) int -> let x = pFunc(n,p) x
    let rst = funcx((x int, y float) int -> x * y, 3, 5)

    /*
    Funções sem retorno
    */
    fn fnInter() {
        fn fnInter1() {
           let x = 10
           fn fnInter2() {
              let x = 10
           }
           fnInter2()
           fnInter2()
        }
        fnInter1()
        let x = 10
    }
    fnInter()

}